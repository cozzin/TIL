# 칼럼1: 조개 껍질 깨기

### 1.1 대화

> 내 실수는 그의 질문에 그냥 답하려고 했던 것이었다.
> 

> 컨텍스트를 알면 문제가 더욱 명확해진다.
> 

모든 상황에 적합한 해답은 없다. 컨텍스트에 따라 좋은 해답이 달라지는 것을 알 수 있다.

[좋은 코드란 무엇인가](https://gyuwon.github.io/blog/2020/07/31/what-is-good-code.html)

> 좋은 코드는 맥락에 따라 달라진다. 그러니까 ‘좋은’이란 표현은 코드를 수식하기에 부족하다. 프로토타이핑에 적합한 코드, 유지보수하기 쉬운 코드, 전력효율이 높은 코드, 응답시간이 짧은 코드, 프레임 수를 유지하는 코드, GC를 덜 자극하는 코드 같은 건 있지만 그냥 좋은 코드란 존재하지 않는다.
> 

### 1.2 정확한 문제 기술

> 문제를 공략하기 전에, 우리가 알고 있는 것을 편견이 없는 유용한 형태로 정리해 보자.
> - 입력: 최대 n개의 양의 정수를 포함하는 파일로 ~
> - 출력: 입력된 정수를 오름차순으로 정렬한 리스트
> - 제약조건: 메모리를 많아야 대략 1MB 정도를 사용할 수 있고 ~
> 

### 1.3 프로그램 디자인

1. 디스크 기반의 머지 정렬
    1. 기본 200 줄 → 리팩토링 수십줄
    2. 구현하는데 며칠 걸림
2. 다중 패스 정렬
    1. 문제의 특별한 성질을 더 많이 이용
    2. 만약 각 숫자를 7바이트에 저장 → 1MB에 143,000개 저장 가능
    3. 만약 각 숫자를 32 비트 정수로 표현 → 1MB에 250,000개 저장 가능
    4. 10000000개의 숫자가 있을 수 있으니, 40번 반복해서 정렬해야 함
        1. 🤔 모르는 점: 40 번 나눠서 정렬하는데 어떻게 누적되어서 정렬되는가?
3. 놀라운 정렬 (ㅋㅋ;;)
    1. 입력 파일의 모든 숫자를 → 가능한 메모리 위에 올려야 함
    2. 많은 숫자를 메모리에 어떻게 올릴 것인가????
    

### 1.4 구현 스케치

문제의 특성

- 상대적으로 작은 범위 내의 입력
- 중복된 숫자가 없음
- 각 레코드에 정수 이외의 다른 연관된 데이터가 없음

bitmap 또는 bitvector 표현법 사용 가능!

ex) {1, 2, 3, 5, 8, 13}

011101000100001000000

```
/* 1단계: 모두 0으로 초기화 */
for i = [0, n)
    bit[i] = 0

/* 2단계: 존재하는 수자를 비트맵에 표시 */
for each i in the input file
    bit[i] = 1

/* 3단계: 정렬된 결과를 기록 */
for i = [0, n)
    if bit[i] == 1
        write i on the output file
```

### 1.5 원리

교훈: 작은 문제에 대한 주의 깊은 분석으로 때로는 엄청난 실질적 이익을 얻을 수 있다.

한계: 그러나 이 프로그램의 특화된 구조는 특정 부분의 명세가 변경될 경우 수정하기 어려울 것이다.

- 정확한 문제 정의
- 시간-공간 트레이드오프인 것과 아닌 것
    
    > 그러나 내 경험상 프로그램이 사용하는 공간을 줄이면 그 실행시간 역시 줄어드는 경우가 자주 있었다. p.27
    > 
- 단순한 디자인

## 🤸 연습문제

[programming-pearls/Column1_Cracking_the_Oyster at main · cozzin/programming-pearls](https://github.com/cozzin/programming-pearls/tree/main/Column1_Cracking_the_Oyster)

### 연습문제 1

set, sort를 이용한 정렬

1. 데이터 전부를 메모리로 읽어온다
2. 집합에 데이터를 담는다
3. 정렬한다

### 연습문제 2

비트벡터 = 중복되지 않는 정수 집합을 비트로 나타내는 방식

- bit shift 이해하는게 오랜만에 보니까 엄청 어려웠음
- `i >> shift` 
  - i를 오른쪽으로 shift 만큼 이동시키면 shift만큼 나눗셈 하는 효과
- `i & mask`
  - i & mask 하면 mask 만큼 mod(%) 해주는 효과
- `1 << (i & mask)`
  - `i % mask`에 해당하는 값을 1로 지정

### 연습문제 3

여러분의 시스템에서 비트맵 정렬을 구현, 실행시간 측정해보기. n = 10,000,000

- swift로 작성해서 그런지, 뭔가 비효율적인 부분이 남아있는건지? 비트벡터 사용한 방식이 너무 오래걸려서 제대로 측정 하지 않음 😭

### 연습문제 4

0 ~ n-1 사이의 k개의 정수를 랜덤한 순서로 가지는 파일 만들기
