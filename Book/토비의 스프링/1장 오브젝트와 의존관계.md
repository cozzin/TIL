# 1장 오브젝트와 의존관계

Spring은 객체지향 설계 원칙대로 개발할 수 있게 도와주는 framework 이다. 변화에 효과적으로 대처하기 위해서 분리와 확장을 고려한 설계를 해야한다. 책의 1장 부터 객체지향의 다양한 개념들이 쏟아진다. 객체지향 종합 선물세트 같은 느낌이다.

책의 예제는 DB 연결과 사용을 하나의 객체에서 하는 객체에서 출발한다. 친절하고 실력있는 개발자에게 코드리뷰 받는 느낌이었다. 확장에 취약한 부분이 어느 곳이고, 어떤 이론적 배경이 있는지 설명해준다. 이런 점진적인 코드 수정은 온라인 강의였다면 훨씬 빠르게 설명되었을 것 같다. 내 경우엔 책으로 이런 과정을 보니 무슨 일이 일어났는지 여러번 곱씹을 수 있어서 좋았다.

여러가지 역할을 가지고 있는 객체(책에서 초난감 DAO라고 부른다)를 아래와 같은 방식으로 개선시켜 나간다.

* 메소드 추출
* 상속을 통한 분리
* 위임을 통한 분리: 위임을 통한 분리를 하고나니 클라이언트에서 오브젝트를 주입해줘야하는 일이 생겼다. 
* 관계설정 책임의 분리: Factory가 이 역할을 해줄 수 있다

여기까지 오면 왜 IoC 컨테이너가 왜 필요한지 알 수 있다. 관계 설정이 필요할 때 마다 Factory를 만들어내는 것 대신 컨테이너를 사용하면 편리하다. 그 뿐 아니라 [[Singleton Registry]]의 역할도 해준다.

## 스터디 토론

### 인터페이스 없이 Bean으로 만들어서 주입하면 안되나?
그 구현의 변경에 얼마나 영향을 받느냐에 따라 결정될 수 있는 문제
굳이 인터페이스를 써서 구현을 감출 것이 아니라면, 서비스 객체는 인터페이스 잘 안만드는 사람들이 많이 있음. 그럴거면 DI 사용하는 이유가 없어짐.
인터페이스 항상 만드는 것을 추천!
[# 안정된 의존관계 원칙과 안정된 추상화 원칙에 대하여](https://techblog.woowahan.com/2561/)

### 수정자 주입 괜찮나?
스프링이 생성자 주입을 권장할 것 같았는데, 오히려 수정자 주입의 편리함이 강조되는 것 같았어요.
vol.2에 가면 더 자세한 내용이 나옴!
스프링 개발에서 setter 통해서 의존관계 설정이 자연스러운 것은 자바빈에서 setter 사용한 경우가 많았기 때문. 의존관계가 optional한 경우 setter method 사용할 수 있음

생성자 주입이 가지는 단점. 같은 타입의 파라미터가 순서가 뒤바뀌면 검증이 되지 않음.

같은 파입의 파라미터 순서가 바뀌는걸 막는 기법도 있다고 함 -> 조사해보기

서버는 오브젝트를 요청 받을 때 마다 새롭게 오브젝트를 만들면, 성능에 큰 저하를 가져옴
그래서 상태값을 안가지는 싱글톤을 사용함

특별한 Scope를 가지는 경우 Bean이 싱글톤이 아닐 수 있음
예를 들어 세션 Scope. 세션 마다 독립적인 Bean이 만들어지게 할 수 있음.
이 Scope 안에서만 의미를 가지게 만들 수 있음.
잘 안씀.

### XML 의존관계 설정

XML 사용해서 의존관계 설정하는게 과연 좋은건지 궁금했습니다! 텍스트 파일의 일종인 XML을 사용하면, 클래스의 네이밍 변화가 있거나 파라미터가 추가될 때 XML도 바꿔줘야하는데요 그러면 변화에 너무 취약한게 아닌가? 하는 의문이 들었어요 그리고 XML로 관계설정하는 방식을 실무에서 많이 사용하시는지 궁금했습니다

-> 코드를 빌드하지 않고 XML 파일을 교체해주면 의존관계를 바꿀 수 있음.
스프링 3.1 에서 혁신적인 방법이었음.
두 사람이 XML 파일을 변경하면 conflict 발생함.
무튼 지금 트렌드는 XML을 안쓰는 것

구성 정보를 애플리케이션에서 분리해두는 것이 스프링 핵심

### Annotation vs XML
Annotation을 쓰면 정보를 하나 생략할 수 있음. 
Gavin King은 XML을 쓰는 것은 코드 중복이다라고 말하기도 했음.

어떤 정보를 모아두는게 좋은지, 분리하는게 좋은지 정답은 없음.

서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다 -> 여러개의 JVM에 분산되어 설치되는 경우 싱글톤이 하나만 있는 것은 아님, 이건 무슨 말일까? 서버를 여러개를 띄운다는 의미인지?

